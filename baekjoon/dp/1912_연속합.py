n = int(input())
data = list(map(int, input().split()))
dp = [data[0]]

for i in range(len(data) - 1):
    dp.append(max(dp[i] + data[i+1] , data[i+1]))
print(max(dp))

'''
처음에 바로 알고리즘 떠오른게 있었는데 긴가민가해서 여러번 케이스로 생각해보았는데 확신이 들지 않았다
여러 방면에서 생각해보다가 결국 인터넷에 잠깐 검색해 보았는데
처음에 떠오른 방법이 정답이었다
조금 더 집중해서 케이스 몇번 더 대입해봤으면 검색없이 완벽히 풀어보는건데 아깝다

이 문제의 태그는 다이나믹 프로그래밍이므로 무조건 각 상황을 보관해줄 dp 배열을 선언한다
그다음 두번째 이상 원소는
max((바로 전 위치에 있는 인덱스의 dp값) + (해당 위치 원소값), 해당 위치 원소값)에 따라 나온 값을 dp에 저장한다

최종적으로 dp배열의 값중 최대값을 출력하면된다
'''
